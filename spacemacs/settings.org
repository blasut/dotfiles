#+PROPERTY: header-args    :results silent

Trying to get some order up in here
* Defaults and simple binding
  #+BEGIN_SRC emacs-lisp
  (setq-default evil-escape-key-sequence "fj")
  (setq-default evil-escape-delay 0.1)
  #+END_SRC
  lets use truncate lines instead of fci mode
  #+BEGIN_SRC emacs-lisp
  (spacemacs/toggle-truncate-lines-on)
  #+END_SRC

* Defuns 
** Insert my files
   Used for reading all the contents of every file in a directory
   #+BEGIN_SRC emacs-lisp 
  (defun insert-my-files ()
    (interactive)
    (let ((dir (read-directory-name "Directory to insert: ")))
      (mapc #'(lambda (file) 
                (let ((file-full (concat dir file)))
                  (insert-file-contents file-full)))
            (cddr (directory-files dir)))))
   #+END_SRC
   
** open-file-in-new-buffer
   #+BEGIN_SRC emacs-lisp
   (defun open-file-in-new-buffer (filename)
     "Opens a file in a new buffer"
     (interactive)
     (switch-to-buffer (find-file-noselect filename)))
   #+END_SRC

** open-notes
   #+BEGIN_SRC emacs-lisp
      (defun open-notes ()
        (interactive)
        (split-window-right)
        (open-file-in-new-buffer "~/Dropbox/notes/notes.org"))
   #+END_SRC

** open-work-notes
   #+BEGIN_SRC emacs-lisp
      (defun open-work-notes ()
        (interactive)
        (split-window-right)
        (open-file-in-new-buffer "~/Dropbox/notes/work.org"))
   #+END_SRC

** visit-ielm
   doesn't actually work
   #+BEGIN_SRC emacs-lisp
   (defun visit-ielm ()
     "Create or visit a `ielm' buffer."
     (interactive)
     (if (not (get-buffer "*ielm*"))
         (progn
           (split-window-sensibly (selected-window))
           (other-window 1)
           (ielm))
       (switch-to-buffer-other-window "*ielm*")))
   #+END_SRC
   

* Example of dir-locals
#+BEGIN_SRC emacs-lisp :tangle no
((nil . ((projectile-globally-ignored-file-suffixes . ( ".cs" ".ttf" ))
         (eval . (set (make-local-variable 'projectile-globally-ignored-directories)
                      (append projectile-globally-ignored-directories
                              (push "FOLDERNAME" projectile-globally-ignored-files)))))
      ))
#+END_SRC
   
* Key bindings
  my own keybindings
  #+BEGIN_SRC emacs-lisp
 (spacemacs/set-leader-keys "on" 'open-notes)
 (spacemacs/set-leader-keys "ow" 'open-work-notes)
 (spacemacs/set-leader-keys "oc" 'org-capture)
  #+END_SRC
  orgmobile stuff
  #+BEGIN_SRC emacs-lisp
 (spacemacs/set-leader-keys "omp" 'org-mobile-pull)
 (spacemacs/set-leader-keys "omu" 'org-mobile-push)
  #+END_SRC

* auto complete
#+BEGIN_SRC emacs-lisp :tangle no
 (add-hook 'company-mode-hook
            (lambda()
              (define-key ac-mode-map (kbd "M-.") 'ac-complete)
              ))
#+END_SRC

* regex for js
  Regex for transforming a old react create class function to es6 function with correct scope

  \(^\s-\)\(\(\w+\s-?\)\((.*)\)\s-*{\)$\1\3 = \4 => {

* Golden ratio
  #+BEGIN_SRC emacs-lisp
  (golden-ratio-mode 1)
  #+END_SRC

* aggressive indent mode
  #+BEGIN_SRC emacs-lisp
(global-aggressive-indent-mode)
  #+END_SRC
  lets ignore some stuff
  #+BEGIN_SRC emacs-lisp
  (add-to-list 'aggressive-indent-excluded-modes 'slim-mode)
  #+END_SRC

* show path in buffer title
  #+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
  #+END_SRC

* Mac + Swedish keyboard bindings
  #+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)  ; set command to meta
  (setq mac-option-modifier 'super)  ; set option to super
  (setq ns-function-modifier 'hyper) ; set FN to hyper modifier
  #+END_SRC
  #+BEGIN_SRC emacs-lisp :tangle no
  (define-key key-translation-map (kbd "s-8") (kbd "["))
  (define-key key-translation-map (kbd "s-(") (kbd "{"))
  (define-key key-translation-map (kbd "s-9") (kbd "]"))
  (define-key key-translation-map (kbd "s-)") (kbd "}"))
  (define-key key-translation-map (kbd "s-7") (kbd "|"))
  (define-key key-translation-map (kbd "s-/") (kbd "\\"))
  (define-key key-translation-map (kbd "s-2") (kbd "@"))
  (define-key key-translation-map (kbd "s-4") (kbd "$"))
  #+END_SRC

* Evil mode rebindings
  I like swiper
  #+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "/") 'swiper)
  #+END_SRC

  Really nice to keep pasting after the first paste.
  #+BEGIN_SRC emacs-lisp :tangle no
  (defun evil-paste-after-from-0 ()
    (interactive)
    (let ((evil-this-register ?0))
      (call-interactively 'evil-paste-after)))

  ;(define-key evil-visual-state-map "p" 'evil-paste-after-from-0)
  #+END_SRC

  Insert state as default state when commiting

  #+BEGIN_SRC emacs-lisp
  (add-hook 'git-commit-mode-hook 'evil-insert-state) 
  #+END_SRC

  
* Web-mode and js2-mode binding
   #+BEGIN_SRC emacs-lisp
      (setq-default
       ;; js2-mode
       js2-basic-offset 2
       js-indent-level 2
       js2-strict-missing-semi-warning nil
       js2-strict-trailing-comma-warning nil
       ;; web-mode
       css-indent-offset 2
       web-mode-markup-indent-offset 2
       web-mode-css-indent-offset 2
       web-mode-code-indent-offset 2
       web-mode-attr-indent-offset 2)
      (add-to-list 'auto-mode-alist '("\\.ejs\\'" . js2-mode))
      ;; react config
      (with-eval-after-load 'web-mode
        (add-to-list 'web-mode-indentation-params '("lineup-args" . nil))
        (add-to-list 'web-mode-indentation-params '("lineup-concats" . nil))
        (add-to-list 'web-mode-indentation-params '("lineup-calls" . nil)))
   #+END_SRC

* Smartparens
   autopairing is sort of nice
   #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-k") 'sp-kill-hybrid-sexp)
      (global-set-key (kbd "M-k") 'sp-backward-kill-sexp)
   #+END_SRC

* PHP-mode
   #+BEGIN_SRC emacs-lisp
  (add-hook 'php-mode-hook 'my-php-mode-hook)
  (defun my-php-mode-hook ()
    (setq indent-tabs-mode t)
    (let ((my-tab-width 4))
      (setq tab-width my-tab-width)
      (setq c-basic-indent my-tab-width)
      (set (make-local-variable 'tab-stop-list)
           (number-sequence my-tab-width 200 my-tab-width))))
   #+END_SRC

* Org-mode
** org babel
    #+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((js         . t)
     (emacs-lisp . t)
     (python     . t)
     (lisp       . t)
     (clojure    . t)
     (dot        . t))))
    #+END_SRC

** eval in repl with org mode
    #+BEGIN_SRC emacs-lisp
    (use-package org-babel-eval-in-repl
     :after org
     :init (setq eir-jump-after-eval nil)
     :config
     (progn
       (define-key org-mode-map (kbd "C-<return>") 'ober-eval-in-repl)
       (define-key org-mode-map (kbd "M-<return>") 'ober-eval-block-in-repl)))
    #+END_SRC

** pretty source code blocks
    #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'org-ref
      (setq org-edit-src-content-indentation 0
          org-src-tab-acts-natively t
          org-src-fontify-natively t
          org-confirm-babel-evaluate nil
          org-support-shift-select 'always))
    #+END_SRC

** Use org-ref and bibtext stuff
   some defaults
    #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'org-ref
      (setq org-ref-bibliography-notes "~/Dropbox/notes/reading/index.org"
            org-ref-default-bibliography '("~/Dropbox/notes/reading/index.bib")
            org-ref-pdf-directory "~/Dropbox/notes/reading/lib/")
      (setq bibtex-completion-bibliography "~/Dropbox/notes/reading/index.bib"
            bibtex-completion-library-path "~/Dropbox/notes/reading/lib"
            bibtex-completion-notes-path "~/Dropbox/notes/reading/index.org"))

    #+END_SRC
    I wanna have auto downloads of pds...
    #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'org-ref
      (require 'doi-utils))
    #+END_SRC
    Nice with book support
    #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'org-ref
      (require 'org-ref-isbn))
    #+END_SRC
    Sweet with url drag and drop
    #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'org-ref
      (require 'org-ref-url-utils))
    #+END_SRC
    


** fontify whole line
   Fontify the whole line for headings (with a background color).
   wut? no idea
   #+BEGIN_SRC emacs-lisp
   (with-eval-after-load 'org-ref
     (setq org-fontify-whole-heading-line t))
   #+END_SRC

   #+RESULTS:

** add todo files to org agenda
   Should work when not using a remote todo file. This adds my projectile todo files to the agenda
  
   this is not working atm
   #+BEGIN_SRC emacs-lisp :tangle no
   (with-eval-after-load 'org
     (require 'org-projectile)
     ;;(push (org-projectile:todo-files) org-agenda-files)
     (setq org-agenda-files (append org-agenda-files (org-projectile:todo-files))))
   #+END_SRC
** org capture templates
   #+BEGIN_SRC emacs-lisp
   (setq org-capture-templates
         '(("n" "Note" entry (file "~/Dropbox/notes/notes.org" "Notes")
            "* %?\n%T" :prepend t)
           ("w" "Work Note" entry (file "~/Dropbox/notes/work.org" "Work")
            "* %?\n%T" :prepend t)
           ("l" "Link" entry (file+headline "~/Dropbox/notes/stuff.org" "Links")
            "* %? %^L %^g \n%T" :prepend t)
           ("b" "Blog idea" entry (file+headline "~/Dropbox/notes/stuff.org" "Blog Topics")
            "* %?\n%T" :prepend t)
           ("c" "Culture" entry (file+headline "~/Dropbox/notes/stuff.org" "Culture")
            "* %? %^L %^g \n%T" :prepend t)
           ("t" "To Do Item" entry (file "~/Dropbox/notes/TODOs.org" "To Do Items")
            "* TODO %?\n%T" :prepend t)
           ("j" "Journal" entry (file+datetree "~/Dropbox/notes/journal.org")
            "* %?\nEntered on %U\n  %i\n")))
   #+END_SRC
** insert mode when capturing
  #+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (add-hook 'org-capture-mode-hook 'evil-insert-state))
  #+END_SRC
** orgmobile
   I guess this is a more general setting, but is it alright, because my notes folder has evolved to a general org-folder
   #+BEGIN_SRC emacs-lisp
   (setq org-directory "~/Dropbox/notes")
   #+END_SRC
   now for the good stuff
   #+BEGIN_SRC emacs-lisp
   (setq org-mobile-inbox-for-pull "~/Dropbox/notes/flagged.org")
   (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
   #+END_SRC
   which files do I want to sync?
   #+BEGIN_SRC emacs-lisp
        (setq org-mobile-files (list "~/Dropbox/notes/journal.org" 
                                     "~/Dropbox/notes/stuff.org"
                                     "~/Dropbox/notes/TODOs.org"))
   #+END_SRC
** setup org agenda files
   #+BEGIN_SRC emacs-lisp
   (setq org-agenda-files (append org-agenda-files (list "~/Dropbox/notes/TODOs.org"
                                                         "~/Dropbox/notes/stuff.org"
                                                         "~/Dropbox/notes/journal.org"
                                                         "~/Dropbox/notes/reading/index.org"
                                                         "~/Dropbox/notes/notes.org")))
   #+END_SRC

** set up places for refile
   #+BEGIN_SRC emacs-lisp
   (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
   #+END_SRC

* All the icons
  spaceline support
  #+BEGIN_SRC emacs-lisp :tangle no
  (use-package spaceline-all-the-icons 
    :after spaceline
    :config (spaceline-all-the-icons-theme))
  #+END_SRC
  
* clojure
  #+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'cider-browse-spec-mode 'insert)
  (evil-set-initial-state 'cider-browse-spec-view-mode 'insert)
  (evil-set-initial-state 'cider-browse-spec-example-mode 'insert)
  #+END_SRC

it's not sending the right sexp to the repl... this makes it work as it should
#+BEGIN_SRC emacs-lisp
(defun blasut/fix-last-sexp-point-when-using-evil (orig-fun &rest args)
  "In normal-state or motion-state, last sexp ends at point."
  (if (or (evil-normal-state-p) (evil-motion-state-p))
      (save-excursion
        (unless (or (eobp) (eolp)) (forward-char))
        (apply orig-fun args))
    (apply orig-fun args)))
#+END_SRC

using the newer advice system
#+BEGIN_SRC emacs-lisp
(advice-add 'cider-last-sexp :around #'blasut/fix-last-sexp-point-when-using-evil)
#+END_SRC

REPLs are the new black
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.clj.repl\\'" . clojure-mode))
#+END_SRC

pretty print by default
#+BEGIN_SRC emacs-lisp
(setq cider-repl-use-pretty-printing t)
#+END_SRC

I only like the f-function and lambda fancy symbols
#+BEGIN_SRC emacs-lisp
(defun blasut/fancify-clojure-symbols (mode)
  "Pretty symbols for Clojure's anonymous functions and lambdas,
   like (λ [a] (+ a 5)), ƒ(+ % 5)"
  (font-lock-add-keywords mode
                          `(("(\\(fn\\)[\[[:space:]]"
                             (0 (progn (compose-region (match-beginning 1)
                                                       (match-end 1) "λ"))))
                            ("\\(#\\)("
                             (0 (progn (compose-region (match-beginning 1)
                                                       (match-end 1) "ƒ")))))))

(dolist (m '(clojure-mode clojurescript-mode clojurec-mode clojurex-mode))
          (blasut/fancify-clojure-symbols m))

#+END_SRC

while debugging, save a let with the current locals
#+BEGIN_SRC emacs-lisp
(defun cider-debug-create-local-let (start end)
  (interactive "r")
  (if cider--debug-mode-response
      (nrepl-dbind-response cider--debug-mode-response (locals)
        (let* ((code (buffer-substring-no-properties start end))
               (bindings (apply #'append locals))
               (formatted-bindings (mapconcat 'identity bindings " ")))
          (kill-new (format "(let [%s]\n %s)" formatted-bindings code))
          (message "copied let form to kill ring")))
    (message "No debugging information found.")))
#+END_SRC
 
* lisp mode
  lisp mode is for all lisps that are NOT emacs-lisp. Not sure if this doesn't work well with cider
#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-mode-hook 'prettify-symbols-mode)
#+END_SRC

want it to work for slime aswell
#+BEGIN_SRC emacs-lisp
(advice-add 'slime-eval-last-expression-in-repl :around #'blasut/fix-last-sexp-point-when-using-evil)
#+END_SRC

and I don't want slime eval to change my current buffer...
#+BEGIN_SRC emacs-lisp
(defun blasut/slime-eval-last-expression-in-repl (args)
  (interactive "p")
  (let ((script-buffer (current-buffer))
        (res (slime-eval-last-expression-in-repl args)))
    (pop-to-buffer script-buffer t)
    res))

(defun blasut/slime-eval-last-expression-in-repl-focus (args)
  (interactive "p")
  (slime-eval-last-expression-in-repl args)
  (evil-insert-mode))
#+END_SRC
hook it up
#+BEGIN_SRC emacs-lisp
(spacemacs/set-leader-keys-for-major-mode 'lisp-mode "se" 'blasut/slime-eval-last-expression-in-repl)
(spacemacs/set-leader-keys-for-major-mode 'lisp-mode "sE" 'blasut/slime-eval-last-expression-in-repl-focus)
#+END_SRC

* elisp
this should probably not be here, maybe in the spacemacs layer?
anyway check out: https://github.com/syl20bnr/spacemacs/pull/4647/files

might be a good start to "fix" the elisp layer
  #+BEGIN_SRC emacs-lisp
    (defun blasut/my-edebug ()
      (progn
          (evilified-state-evilify-map edebug-mode-map
            :eval-after-load edebug
            :bindings
            ;; normal by spacemacs
            "a" 'edebug-stop
            "s" 'edebug-step-mode
            "S" 'edebug-next-mode

            ;; the rest default bindings... fixed for spacemacs
            "B" 'edebug-next-breakpoint
            "C" 'edebug-Continue-fast-mode
            "E" 'edebug-visit-eval-list
            "G" 'edebug-Go-nonstop-mode
            "I" 'edebug-instrument-callee
            "P" 'edebug-view-outside
            "Q" 'edebug-top-level-nonstop
            ;; "S" 'edebug-stop
            "T" 'edebug-Trace-fast-mode
            "W" 'edebug-toggle-save-windows
            "X" 'edebug-set-global-break-condition
            "b" 'edebug-set-breakpoint
            "c" 'edebug-continue-mode
            "d" 'edebug-backtrace
            "e" 'edebug-eval-expression
            "f" 'edebug-forward-sexp
            "g" 'edebug-go-mode
            "h" 'edebug-goto-here
            "i" 'edebug-step-in
            "n" 'edebug-next-mode
            "o" 'edebug-step-out
            "p" 'edebug-bounce-point
            "q" 'top-level
            "r" 'edebug-previous-result
            "t" 'edebug-trace-mode
            "u" 'edebug-unset-breakpoint
            "v" 'edebug-view-outside
            "w" 'edebug-where
            "x" 'edebug-set-conditional-breakpoint
            )
      


          (evilified-state-evilify-map edebug-eval-mode-map
            :eval-after-load edebug
            :bindings
            "a" 'edebug-stop
            "s" 'edebug-step-mode
            "S" 'edebug-next-mode

            ;; the rest default bindings... fixed for spacemacs
            "B" 'edebug-next-breakpoint
            "C" 'edebug-Continue-fast-mode
            "E" 'edebug-visit-eval-list
            "G" 'edebug-Go-nonstop-mode
            "I" 'edebug-instrument-callee
            "P" 'edebug-view-outside
            "Q" 'edebug-top-level-nonstop
            ;; "S" 'edebug-stop
            "T" 'edebug-Trace-fast-mode
            "W" 'edebug-toggle-save-windows
            "X" 'edebug-set-global-break-condition
            "b" 'edebug-set-breakpoint
            "c" 'edebug-continue-mode
            "d" 'edebug-backtrace
            "e" 'edebug-eval-expression
            "f" 'edebug-forward-sexp
            "g" 'edebug-go-mode
            "h" 'edebug-goto-here
            "i" 'edebug-step-in
            "n" 'edebug-next-mode
            "o" 'edebug-step-out
            "p" 'edebug-bounce-point
            "q" 'top-level
            "r" 'edebug-previous-result
            "t" 'edebug-trace-mode
            "u" 'edebug-unset-breakpoint
            "v" 'edebug-view-outside
            "w" 'edebug-where
            "x" 'edebug-set-conditional-breakpoint)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(blasut/my-edebug)
#+END_SRC


* which function mode
  the default is ??? but n/a is nicer I think
  #+BEGIN_SRC emacs-lisp
  (which-function-mode)
  (setq which-func-unknown "n/a")
  #+END_SRC



* when .enving

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.env\\'" . sh-mode))
#+END_SRC
